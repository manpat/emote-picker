<html>
<head>
	<meta charset="utf-8">
	<style>
		html, body { padding: 0; margin: 0; background: #333 }
		* { color: #ddd }

		body {
			height: 100%;
		}

		main {
			display: flex;
			flex-flow: column;
			height: 100%;
		}

		.emote {
			display: inline-block;
			background: #444;
			border-radius: 3px;
			padding: 3px;
			margin: 3px;
			cursor: pointer;
			-webkit-user-select: none;
		}
		.emote:hover {
			background: #555;
			-webkit-transform: scale(1.2, 1.2);
		}

		.emote-group h1 {
			width: 100%;
			background: #222;
			margin: 0;
			padding-left: 0.25em;
			-webkit-user-select: none;
			font-size: 1em;
		}

		#main-container {
			flex: 1 1 auto;
			overflow-y: auto;
			height: 100%;
		}

		#search-bar {
			flex: 0 1 auto;
			width: 100%;
			background: #222;
			border-bottom: 1px solid white;

			display: flex;
		}

		input {
			outline: none;
		}

		input[type="text"] {
			-webkit-appearance: none;
			border: none;
			padding: 6px;
			background: #222;
		}

		input[type="text"].error {
			background: #722;
		}

		input[type="checkbox"] {
			cursor: pointer;
			-webkit-appearance: none;
			padding: 6px;
			background: transparent;

			border-radius: 10%;
		}

		input[type="checkbox"]:hover {
			background: #333;
		}

		input[type="checkbox"]:checked {
			background: #555;
		}

		#search-bar input[type="text"] { flex: 1 1 auto }
		#search-bar #yellow-only {
			flex: 0 0 auto;
			padding-bottom: 10px;
		}
		#search-bar #yellow-only::after { content: "ðŸŸ¡" }

		.hidden {
			display: none;
		}

	</style>
	<script>
		"use strict";

		function send(type, obj) {
			let string = JSON.stringify({
				type: type,
				... (obj || {})
			});

			window.external.invoke(string);
		}

		function print(...args) {
			send("debug", {text: JSON.stringify(args)});
		}

		function on_message(data) {
			switch (data.type) {
				case "init":
					init();
					break;

				case "update":
					render_list(data.entries);
					break;

				default:
					print(`unhandled message type: ${data.type}`);
					break;
			}
		}

		function on_click(e) {
			send("copy_to_clipboard", {text: e.target.innerText});
		}

		function init() {
			let filter_bar = document.querySelector("#search-bar input[type='text']");
			let hide_tones_check = document.querySelector("#yellow-only");

			filter_bar.addEventListener("input", filter_emotes);
			hide_tones_check.addEventListener("input", filter_emotes);
		}

		async function filter_emotes() {
			let filter_bar = document.querySelector("#search-bar input[type='text']");
			let hide_tones_check = document.querySelector("#yellow-only");

			filter_bar.classList.remove("error");

			let filter = filter_bar.value.trim();
			let show_tones = !hide_tones_check.checked;

			let rate_limiter_count = 0;
			const rate_limit = 500;

			function emote_is_toned(el) {
				const tones = ["ðŸ»", "ðŸ¼", "ðŸ½", "ðŸ¾", "ðŸ¿"];

				for (let tone of tones) {
					if (el.innerText.includes(tone)) {
						return true;
					}
				}

				return false;
			}

			let visibility_fn;

			if (filter.length > 0) {
				let filter_re;
				try {
					filter_re = new RegExp(filter, "i");
				} catch (e) {
					filter_bar.classList.add("error");
					return;
				}

				visibility_fn = (el) => {
					if (!show_tones && emote_is_toned(el)) {
						return false;
					}

					return filter_re.test(el.title)
						|| filter_re.test(el.dataset.tags);
				};
			} else {
				visibility_fn = (el) => show_tones || !emote_is_toned(el);
			}

			for (let el of document.querySelectorAll(".emote")) {
				if (visibility_fn(el)) {
					el.classList.remove("hidden");
				} else {
					el.classList.add("hidden");
				}

				rate_limiter_count++;
				if (rate_limiter_count > rate_limit) {
					await next_frame();
					rate_limiter_count = 0;
				}
			}

			for (let group of document.querySelectorAll(".emote-group")) {
				let el = group.querySelector(".emote:not(.hidden)");
				if (el == null) {
					// all child emotes are hidden
					group.classList.add("hidden");
				} else {
					// there's at least one child emote not hidden
					group.classList.remove("hidden");
				}
			}
		}

		function render_entry(entry) {
			let el = document.createElement("div");
			el.innerText = entry.text;
			el.classList.add("emote");
			el.title = entry.name;
			el.dataset.tags = entry.tags.join(" ");
			el.addEventListener("click", on_click);
			return el;
		}

		async function render_list(entries) {
			let list = document.querySelector("#main-container");
			list.innerHTML = "";

			const chunk_size = 100;
			const chunk_count = entries.length / chunk_size + 1;

			let groups = {};

			for (let chunk = 0; chunk < chunk_count; chunk++) {
				let start = chunk * chunk_size;
				let end = Math.min((chunk+1) * chunk_size, entries.length);

				for (let i = start; i < end; i++) {
					let entry = entries[i];
					let el = render_entry(entry);
					
					let group = groups[entry.group];
					if (typeof group === 'undefined') {
						let group_el = document.createElement("div");
						group_el.classList.add("emote-group")
						group_el.innerHTML = `
							<h1>${entry.group}</h1>
							<div class="emote-list"></div>
						`;
						list.appendChild(group_el);

						group = group_el.querySelector(".emote-list");
						groups[entry.group] = group;
					}

					group.appendChild(render_entry(entries[i]));
				}

				await next_frame();
			}

			await filter_emotes();
		}

		async function next_frame() {
			await new Promise((resolve) => requestAnimationFrame(resolve));
		}

	</script>
</head>
<body>
	<main>
		<div id="search-bar">
			<input type="text" autofocus></input>
			<input id="yellow-only" type="checkbox" checked="checked"></input>
		</div>
		<div id="main-container"></div>
	</main>
</body>
</html>