<html>
<head>
	<meta charset="utf-8">
	<style>
		html, body { padding: 0; margin: 0; background: #333 }
		* { color: #ddd }

		body {
			height: 100%;
		}

		main {
			display: flex;
			flex-flow: column;
			height: 100%;
		}

		.emote {
			display: inline-block;
			background: #444;
			border-radius: 3px;
			padding: 3px;
			margin: 3px;
			cursor: pointer;
			-webkit-user-select: none;
		}
		.emote:hover {
			background: #555;
			-webkit-transform: scale(1.2, 1.2);
		}

		.emote-group h1 {
			width: 100%;
			background: #222;
			margin: 0;
			padding-left: 0.25em;
			-webkit-user-select: none;
			font-size: 1em;
		}

		#main-container {
			flex: 1 1 auto;
			overflow-y: auto;
			height: 100%;
		}

		#search-bar {
			flex: 0 1 auto;
			width: 100%;
			background: #222;
		}

		#search-bar input {
			-webkit-appearance: none;
			width: 100%;
			border: none;

			background: #222;
			padding: 6px;
			border-bottom: 1px solid white;
		}

		.hidden {
			display: none;
		}

	</style>
	<script>
		"use strict";

		function send(type, obj) {
			let string = JSON.stringify({
				type: type,
				... (obj || {})
			});

			window.external.invoke(string);
		}

		function print(...args) {
			send("debug", {text: JSON.stringify(args)});
		}

		function on_message(data) {
			switch (data.type) {
				case "init":
					init();
					break;

				case "update":
					render_list(data.entries);
					break;

				default:
					print(`unhandled message type: ${data.type}`);
					break;
			}
		}

		function on_click(e) {
			send("copy_to_clipboard", {text: e.target.innerText});
		}

		function init() {
			let input = document.querySelector("#search-bar input");
			input.addEventListener("input", function(e) {
				// print("fuk ", e.target.value);
				// send("new_filter")
				let filter = e.target.value;
				filter_emotes(filter);
			});
		}

		async function filter_emotes(filter) {
			let emotes = document.querySelectorAll(".emote");

			let rate_limiter_count = 0;
			const rate_limit = 800;

			filter = filter.trim();

			if (filter.length === 0) {
				for (let el of emotes) {
					el.classList.remove("hidden");

					rate_limiter_count++;
					if (rate_limiter_count > rate_limit) {
						await next_frame();
						rate_limiter_count = 0;
					}
				}
			} else {
				let filter_re;
				try {
					filter_re = new RegExp(filter, "i");
				} catch (e) {
					// We don't care about syntax errors
					return;
				}

				function matches(el) {
					return filter_re.test(el.title)
						|| filter_re.test(el.dataset.tags);
				}

				for (let el of emotes) {
					let visible = matches(el);

					if (visible) {
						el.classList.remove("hidden");
					} else {
						el.classList.add("hidden");
					}

					rate_limiter_count++;
					if (rate_limiter_count > rate_limit) {
						await next_frame();
						rate_limiter_count = 0;
					}
				}
			}

			for (let group of document.querySelectorAll(".emote-group")) {
				let el = group.querySelector(".emote:not(.hidden)");
				if (el == null) {
					// all child emotes are hidden
					group.classList.add("hidden");
				} else {
					// there's at least one child emote not hidden
					group.classList.remove("hidden");
				}
			}
		}

		function render_entry(entry) {
			let el = document.createElement("div");
			el.innerText = entry.text;
			el.classList.add("emote");
			el.title = entry.name;
			el.dataset.tags = entry.tags.join(" ");
			el.addEventListener("click", on_click);
			return el;
		}

		async function render_list(entries) {
			let list = document.querySelector("#main-container");
			list.innerHTML = "";

			const chunk_size = 100;
			const chunk_count = entries.length / chunk_size + 1;

			let groups = {};

			for (let chunk = 0; chunk < chunk_count; chunk++) {
				let start = chunk * chunk_size;
				let end = Math.min((chunk+1) * chunk_size, entries.length);

				for (let i = start; i < end; i++) {
					let entry = entries[i];
					let el = render_entry(entry);
					
					let group = groups[entry.group];
					if (typeof group === 'undefined') {
						let group_el = document.createElement("div");
						group_el.classList.add("emote-group")
						group_el.innerHTML = `
							<h1>${entry.group}</h1>
							<div class="emote-list"></div>
						`;
						list.appendChild(group_el);

						group = group_el.querySelector(".emote-list");
						groups[entry.group] = group;
					}

					group.appendChild(render_entry(entries[i]));
				}

				await next_frame();
			}
		}

		async function next_frame() {
			await new Promise((resolve) => requestAnimationFrame(resolve));
		}

	</script>
</head>
<body>
	<main>
		<div id="search-bar">
			<input type="text"></input>
		</div>
		<div id="main-container"></div>
	</main>
</body>
</html>